## Compressed Instructions on RV32 (Git Tag: RV32IM_Not_C)
The RISC-V ISA defines several optional extensions that a particular CPU may choose to implement. The options all have a one-letter identifier, so "M" for Multiplication and Division instructions, "F" for floating-point, and "C" for Compression.

The C option defines 16-bit alternative encodings for the most commonly used 32-bit instructions. The mapping is one-to-one in both directions, so compressed instructions are decoded with a simple table look-up in the CPU, or some simple logic.

Using the compressed instructions is easy, and we've been using them so far in all these tests, since the default for the compiler is to set the target architecture to "RV32IMC". There no change to the compiler's output, but the assembler generates the compressed opcodes as appropriate. There's also a bit of work done by the linker to make sure that jump and branch instructions all end up going to the right place.

Performance-wise, the compressed instructions can be a mixed blessing. They certainly reduce code size, so you'd expect instruction cache hit rate to improve. On the other hand, there must be some overhead is the extra instruction decoding logic, and then there's the issue of instruction alignment.

In RV32IM (no C!) all instructions are 32 bits so always appear "aligned" on a 4-byte boundary. On RV32IMC, this has to change to allow instructions to be aligned on 2-byte boundaries. The performance impact of this change is very difficult to predict, and obviously depends on the very particular details of the CPU. The E31 Core (the RISC-V core at the heart of the HiFive1_Rev_B board) manual states:

"Fetches are always word-aligned and there is a one-cycle penalty for branching to a 32-bit instruction that is not word-aligned." (section 3.1.5)

so there's a performace hit if we branch to a 32-bit instruction that *isn't* 4-byte aligned.

So... that got me thinking... what if we tell the compiler (well.. assembler) *not* to generate the compressed instructions. What effect would that have on code size and performance? This can be done by setting "-march=rv32im" for the compiler - this switch gets passed on to the assembler and linker and they take care of all the rest.

With no compressed instructions, our performance figures look like this:

|Level|Timing_Baseline|Relax_Init|PRE_Scalarmult|Unroll_Multiply|No_Slices|RV32IM_Not_C|
|:-------:|-------:|---:|---:|---:|---:|---:|
|-O0|198.03|191.54|191.40|176.50|177.40|182.15|
|-O1|98.03|95.26|95.03|69.88|69.79|69.94|
|-O2|93.86|88.66|87.06|63.61|58.31|57.77|

so a bit worse at -O0 and -O1 and a bit better at -O2.

As for code size, the quick check with the "riscv32-elf-size" tool tells us that the binary at -O2 is 3648 bytes bigger without the compressed instructions, so not too bad unless, like me, you started programming on a ZX81 with 1k of RAM.
