
;; Function q.op (q__op, funcdef_no=2, decl_uid=4567, cgraph_uid=0, symbol_order=0)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
l = &NONLOCAL
r = &NONLOCAL
ESCAPED = l
ESCAPED = r
R.2 = NONLOCAL
ESCAPED = &R.2
R.1 = NONLOCAL
ESCAPED = &R.1
R.0 = NONLOCAL
ESCAPED = &R.0
D.4568 = NONLOCAL
ESCAPED = D.4568

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL R.2 R.1 R.0 }
NONLOCAL = { ESCAPED NONLOCAL } same as D.4568
STOREDANYTHING = { }
INTEGER = { ANYTHING }
l = { NONLOCAL }
r = { NONLOCAL } same as l
p__Omultiply = { }
R.2 = { ESCAPED NONLOCAL }
p__n3 = { }
R.1 = { ESCAPED NONLOCAL }
p__n2 = { }
R.0 = { ESCAPED NONLOCAL }
p__n1 = { }
D.4568 = { ESCAPED NONLOCAL }


Alias information for Q.Op

Aliased symbols

R.2, UID D.4587, interfaces__integer_64[16], is addressable
R.1, UID D.4582, interfaces__integer_64[16], is addressable
R.0, UID D.4578, interfaces__integer_64[16], is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4578 D.4582 D.4587 } (escaped)

Flow-insensitive points-to information

l_2(D), points-to non-local, points-to NULL, points-to vars: { }
r_3(D), points-to non-local, points-to NULL, points-to vars: { }

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
q.op (interfaces__integer_64[16] & l, interfaces__integer_64[16] & r)
{
  interfaces__integer_64 R.2[16];
  interfaces__integer_64 R.1[16];
  interfaces__integer_64 R.0[16];

  <bb 2> [local count: 1073741825]:
  R.2 = p."*" (l_2(D), r_3(D)); [return slot optimization]
  R.1 = p.n3 (&R.2); [return slot optimization]
  R.2 ={v} {CLOBBER};
  R.0 = p.n2 (&R.1); [return slot optimization]
  R.1 ={v} {CLOBBER};
  <retval> = p.n1 (&R.0); [return slot optimization]
  R.0 ={v} {CLOBBER};
  return <retval>;

}



;; Function q.op2 (q__op2, funcdef_no=3, decl_uid=4570, cgraph_uid=1, symbol_order=1)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
x = &NONLOCAL
D.4571 = *x + UNKNOWN
ESCAPED = D.4571

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
x = { NONLOCAL }
D.4571 = { ESCAPED NONLOCAL }


Alias information for Q.Op2

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

x_2(D), points-to non-local, points-to NULL, points-to vars: { }

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
q.op2 (interfaces__integer_64[16] & x)
{
  <bb 2> [local count: 1073741825]:
  <retval> = *x_2(D);
  return <retval>;

}


